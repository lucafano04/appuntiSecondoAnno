\chapter{Applicazioni della criptografia \texttt{PKI}\&\texttt{TLS}}
\thispagestyle{chapterInit}
\section{Digital Certificates}
    \subsection{Introduzione}
        Il certificato digitale è un documento elettronico che contiene la chiave pubblica di un'entità, come un'organizzazione, un sito web o un individuo ben identificato tramite procedure di verifica dell'identità, spesso legislate da normative nazionali o internazionali. Il certificato è rilasciato da un'autorità di certificazione (CA) riconosciuta a livello internazionale, che garantisce l'identità del titolare del certificato. Il certificato è firmato digitalmente dalla CA, che ne garantisce l'integrità e l'autenticità. Il certificato può essere usato per autenticare l'identità del titolare, per garantire la riservatezza delle comunicazioni e per garantire l'integrità dei dati scambiati.
        Il certificato usa il paradigma della crittografia a chiave pubblica, in cui una chiave è usata per cifrare i dati e l'altra per decifrarli, infatti è composto da un certificato pubblico e da una chiave privata.
    \subsection{Struttura del certificato \texttt{X.509}}
        All'interno del certificato sono presenti le seguenti informazioni:
        \begin{description}
            \item[Version] o versione del certificato, che indica il formato del certificato.
            \item[Serial Number] o numero seriale del certificato, rispetto ad altri certificati rilasciati dalla stessa \texttt{CA}.
            \item[Signature Algorithm ID] o algoritmo di firma digitale usato per firmare il certificato.
            \item[Issuer] o autorità di certificazione, che ha rilasciato il certificato (\texttt{CA}).
            \item[Validity Period] o periodo di validità del certificato.
            \item[Subject] o titolare del certificato che lo ha richiesto, la quale identità è garantita dalla \texttt{CA}.
            \item[Subject Public Key] o chiave pubblica del titolare del certificato (\texttt{PK}).
                \subitem Algoritmo di cifratura asimmetrica usato per cifrare i dati.
                \subitem Valore della chiave pubblica.
            \item[Issuer Unique Identifier] o identificativo univoco della \texttt{CA}.
            \item[Subject Unique Identifier] o identificativo univoco del titolare del certificato.
            \item[Extensions] o estensioni del certificato, che possono contenere informazioni aggiuntive, quali nomi alternativi, restrizioni d'uso, ecc.
            \item[Signature] o firma digitale del certificato rilasciata dalla \texttt{CA} che garantisce l'integrità e l'autenticità del certificato e che questo non sia stato alterato o contraffatto.
        \end{description}
    \subsection{Certificati: domande e risposte}
        \begin{itemize}
            \item Come sono rilasciati i certificati?
            \item Chi può rilasciare i certificati?
            \item Perché dovrei fidarmi di un ente certificatore?
            \item Come posso controllare se un certificato è valido?
            \item Come posso revocare un certificato?
            \item Chi può revocare un certificato?
        \end{itemize}
        La risposta a queste domande è data dalla \texttt{PKI} (\texttt{Public Key Infrastructure}), che è un insieme di tecnologie, standard e procedure che permettono di gestire in modo sicuro le chiavi pubbliche e i certificati digitali.
\section{\textit{Public Key Infrastructure} - \texttt{PKI}}
    Una \texttt{PKI} è un insieme di tecnologie, standard e procedure che permettono di gestire in modo sicuro le chiavi pubbliche e i certificati digitali. Questa infrastruttura garantisce anche la corrispondenza tra le chiavi pubbliche e i titolari delle chiavi, garantendo l'integrità e l'autenticità delle chiavi pubbliche e dei certificati digitali.
    \subsection{Ottenere un certificato}
        Per ottenere un certificato, il titolare deve come prima cosa registrarsi presso una \texttt{CA} autorevole, la quale verifica tramite processi che possono essere automatici o manuali l'identità del richiedente. Una volta verificata l'identità del richiedente questo invia una chiave privata e pubblica da certificare alla \texttt{CA} la quale \texttt{CA} rilascia il certificato, contenete le informazioni del titolare e la chiave pubblica del titolare, questo certificato è firmato digitalmente tramite chiave privata dalla \texttt{CA} e inviato al titolare che ora può distribuirlo.
        \subsubsection{\texttt{ACME} - \texttt{Automated Certificate Management Environment}}
            \texttt{ACME} è un protocollo di gestione automatica dei certificati, che permette di automatizzare il processo di richiesta, rinnovo e revoca dei certificati digitali. Il protocollo è stato sviluppato per semplificare la gestione dei certificati digitali, riducendo i costi e i tempi di gestione dei certificati. Il protocollo è basato su un modello di autorizzazione a due fattori, in cui il richiedente deve dimostrare di avere il controllo del dominio per cui richiede il certificato e di essere autorizzato a richiedere il certificato.
            \paragraph{Let's encrypt} è un'autorità di certificazione che rilascia certificati digitali gratuitamente, tramite il protocollo \texttt{ACME}. Il servizio è stato lanciato nel 2016 con l'obiettivo di rendere l'uso dei certificati digitali più diffuso e sicuro, riducendo i costi e i tempi di gestione dei certificati. Il servizio è automatizzato e permette di ottenere un certificato digitale in pochi minuti, senza dover passare per procedure manuali di verifica dell'identità verificando l'identità del richiedente tramite il controllo del dominio per cui richiede il certificato.
            \paragraph{Funzionamento}\begin{enumerate}
                \item Il richiedente genere una coppia di chiavi pubblica e privata.
                \item Il richiedente dimostra di essere in possesso del dominio per cui richiede il certificato.
                \item Il richiedente richiede il certificato alla \texttt{CA} tramite il protocollo \texttt{ACME}.
                \item La \texttt{CA} verifica il controllo del dominio e rilascia il certificato.
                \item Il richiedente installa il certificato sul proprio server e può revocare o rinnovare il certificato in qualsiasi momento.
            \end{enumerate}
            \paragraph{Verifica del controllo del dominio}\begin{itemize}
                \item \texttt{HTTP-01}: il richiedente deve creare un file con un contenuto specifico e caricarlo sul proprio server web.
                \item \texttt{DNS-01}: il richiedente deve creare un record \texttt{TXT} con un contenuto specifico nel proprio server DNS.
                \item \texttt{TLS-ALPN-01}: il richiedente deve configurare un certificato particolare con una connessione \texttt{TLS} specifica.
            \end{itemize}
    \subsection{Requisiti su \texttt{PKI}}
        In quanto il sistema di \texttt{PKI} è distribuito a livello globale, è necessario che le \texttt{CA} e gli utenti rispettino alcuni requisiti comuni, tra cui: una politica di assegnazione nomi univoca, ogni parte della \texttt{PKI} deve provare ad alla \texttt{TTP} (\textit{Trusted Third Party}) che hanno una identità. Inoltre le \texttt{TTPs} devono controllare che quella identità sia valida e che il richiedente abbia ricevuto quella identità da una fonte affidabile. Infine le \texttt{TTPs} devono garantire che le chiavi pubbliche siano valide e che siano state rilasciate da una fonte affidabile.
        \paragraph{Requisiti dei software} Tutti i software che operano con la \texttt{PKI} devono rispettare alcuni requisiti, tra cui: devono supportare i protocolli standard della \texttt{PKI}, devono supportare i formati standard dei certificati digitali, devono supportare i meccanismi standard di verifica dei certificati digitali, devono supportare i meccanismi standard di revoca dei certificati digitali, devono supportare i meccanismi standard di gestione dei certificati digitali e devono essere aggiornati regolarmente per garantire la sicurezza dei certificati digitali.
        \subsubsection{\texttt{CRL} - \textit{Certificate Revocation List}}
            La \texttt{CRL} è una lista di certificati revocati, che contiene le informazioni sui certificati che sono stati revocati dalla \texttt{CA}. Questa lista viene aggiornata regolarmente dalla \texttt{CA} e distribuita in tutto il modo a orari regolari alle \texttt{RA} (\textit{Registration Authority}) e agli utenti. La \texttt{CRL} contiene le seguenti informazioni sui certificati revocati: il numero seriale del certificato, la data di revoca, il motivo della revoca e la \texttt{CA} che ha revocato il certificato. Una possibile criticità di questo sistema è che la \texttt{CRL} può essere ritardata nella sua distribuzione e quindi un certificato revocato può essere utilizzato per un certo periodo di tempo, non conosciuto per motivi di sicurezza.
    \subsection{Validazione di un certificato}
        La \textbf{validazione di un certificato} è il processo per il quale si verifica che un certificato sia valido, autentico e integro prima di stabilire una connessione \texttt{SSL/TLS} con un server web. Inoltre ci si assicura che il certificato non sia scaduto e che non sia stato revocato dalla \texttt{CA}. Il processo di validazione di un certificato è composto da diversi passaggi: \begin{enumerate}
            \item Il \textit{client} segue la catena di fiducia fino ad arrivare alla \texttt{CA} radice (\texttt{Root CA}).
            \item Ogni certificato nella catena di fiducia è verificato tramite la firma digitale della \texttt{CA} che lo ha rilasciato per garantire l'autenticità e l'integrità del certificato.
            \item Il \textit{client} verifica che il certificato sia valido per il periodo di validità specificato nei certificati.
            \item Viene controllato che il certificato non sia stato revocato dalla \texttt{CA} tramite la \texttt{CRL}.
            \item Infine il \textit{client} verifica che il \texttt{CN} (\textit{Common Name}) o il \texttt{SAN} (\textit{Subject Alternative Name}) del certificato corrisponda al nome del server web a cui si sta connettendo.
        \end{enumerate}
    \subsection{Catena di fiducia}
        La catena di fiducia è una struttura gerarchica che permette di garantire l'autenticità e l'integrità delle chiavi pubbliche e dei certificati digitali. La catena di fiducia è composta da una serie di entità che si fidano l'una dell'altra e che garantiscono l'autenticità e l'integrità delle chiavi pubbliche e dei certificati digitali. La catena di fiducia è basata su un modello gerarchico, in cui le entità sono organizzate in una struttura ad albero, in cui ogni entità è collegata a un'altra entità di livello superiore, fino ad arrivare a un'autorità di certificazione radice (\texttt{Root CA}).
\section{\texttt{SSL} \& \texttt{TLS} introduction}
    Come possiamo sfruttare la crittografia a chiave pubblica e l'infrastruttura \texttt{PKI} per garantire la riservatezza, l'integrità e l'autenticità delle comunicazioni su Internet? La risposta è data dal protocollo \texttt{SSL} (\textit{Secure Socket Layer}) e dal suo successore \texttt{TLS} (\textit{Transport Layer Security}), che permettono di garantire la sicurezza delle comunicazioni su Internet.
    \paragraph{\texttt{SSL}} (\textit{Secure Socket Layer}) è un protocollo di sicurezza che permette di garantire la riservatezza, l'integrità e l'autenticità delle comunicazioni su Internet. Il protocollo è basato su un modello di crittografia a chiave pubblica, in cui una chiave è usata per cifrare i dati e l'altra per decifrarli. Il protocollo è stato sviluppato da Netscape nel 1994 e ha avuto un grande successo, diventando uno standard de facto per la sicurezza delle comunicazioni su Internet.
    \paragraph{\texttt{TLS}} (\textit{Transport Layer Security}) è il successore di \texttt{SSL}, che è stato sviluppato per superare i problemi di sicurezza di \texttt{SSL} e per garantire una maggiore sicurezza delle comunicazioni su Internet. Il protocollo è basato su un modello di crittografia a chiave pubblica, in cui una chiave è usata per cifrare i dati e l'altra per decifrarli. Il protocollo è stato sviluppato dal gruppo di lavoro \texttt{IETF} (\textit{Internet Engineering Task Force}). Esistono varie versioni del protocollo, tra cui \texttt{TLS 1.0} (\texttt{RFC 2246} 1999), \texttt{TLS 1.1} (\texttt{RFC 4346} 2006), \texttt{TLS 1.2} (\texttt{RFC 5246} 2008), \texttt{TLS 1.3} (\texttt{RFC 8446} 2018), la versione \texttt{TLS 1.3} e \texttt{TLS 1.2} sono le più utilizzate e al momento coesistono nella rete.
    \paragraph{Obbiettivo di queste tecnologie} L'obiettivo di queste tecnologie è quello di garantire la riservatezza, l'integrità e l'autenticità delle comunicazioni nel web, proteggendo i dati sensibili degli utenti e garantendo la sicurezza delle transazioni online. Questo anche tramite il protocollo \texttt{HTTPS} (\textit{HyperText Transfer Protocol Secure}), che è una versione sicura del protocollo \texttt{HTTP} che utilizza il protocollo \texttt{SSL} o \texttt{TLS} per garantire la sicurezza delle comunicazioni tra il \textit{client} e il \textit{server} web.
\section{\texttt{TLS} in architetture \textit{client-server}}
    Nelle architetture \textit{client-server} dove uno o più \textit{client} si connettono a un \textit{server} comune eseguendo richieste per ottenere risorse o servizi. Il client provvede una interfaccia per l'utente in modo che questo possa interagire con il server, il server invece fornisce i servizi richiesti dal client molto spesso in maniera trasparente. Solitamente viene usato il protocollo \texttt{TCP} al livello di trasporto per garantire la connessione tra client e server, ma questo non garantisce la sicurezza delle comunicazioni, ma questo non è sufficiente per garantire un canale sicuro tra client e server. In questo schema anche usando il protocollo \texttt{TLS} non è garantita la privacy del canale, questo in quanto un qualsiasi punto nel mezzo della infrastruttura può intercettare i dati scambiati tra client e server, questo accade in quanto \texttt{TLS} garantisce solo sicurezza punto a punto.

    \subsection{\textit{handshake} del \texttt{TLS}}
        Durante il processo di \textit{handshake} vengono negoziate tra \textit{client} e \textit{server} una serie di parametri, tra cui la chiave di codifica che verrà usata per la trasmissione dei dati. In questo \textit{handshake} viene usata la \texttt{PKC} per garantire l'autenticità delle parti e la riservatezza delle comunicazioni. 
    
    \subsection{Dove è posizionato il \texttt{TLS}}
        Il \texttt{TLS} viene posto tra il livello \texttt{TCP/IP} e il livello applicazione. Il \texttt{TLS} fornisce dunque una interfaccia al livello applicazione per garantire la sicurezza delle comunicazioni tra livelli applicazione, ma non ai livelli inferiori. All'interno di questa interfaccia sono presenti due sotto-livelli uno è \textit{TLS handshake protocol} contenente le informazioni di \textit{handshake}, il cambio di chiavi e eventuali parametri di sicurezza, l'altro è il \textit{TLS record protocol} che si occupa di cifrare e decifrare i dati scambiati tra client e server.
\section{\texttt{TLS 1.2} \textit{handshake}}
    Il \textit{handshake} di \texttt{TLS 1.2} è composto da diverse fasi: \begin{enumerate}
        \item \textit{ClientHello} - Il client invia al server un messaggio \textit{ClientHello} contenente i parametri di sicurezza supportati dal client, tra cui la versione di \texttt{TLS} supportata, gli algoritmi di cifratura supportati e i parametri di sicurezza. (vedi sottosezione \ref{subsec:TLSciphersuites})
        \item \textit{ServerHello} - Il server risponde con un messaggio \textit{ServerHello} contenente i parametri di sicurezza scelti dal server (la versione più recente di \texttt{TLS} supportata, gli algoritmi di cifratura supportati e i parametri di sicurezza). Inoltre contiene la \textit{cipher suite} scelta dal server per la comunicazione, oltre ad un identificativo di sessione.
        \item \textit{Server Certificate} - Il \textit{server} \textit{invia} al client il suo certificato digitale, lo scambio di chiavi \textit{server} e la richiesta del certificato \textit{client}. A questo punto l'\textit{handshake} lato \textit{server} è completato. (Comunicazione protetta da \texttt{RSA} o \textit{Diffie-Hellman})
        \item \textit{Client Certificate} - Il \textit{client} invia al \textit{server} il suo certificato digitale, lo scambio di chiavi \textit{client} (Comunicazione protetta da \texttt{RSA} o \textit{Diffie-Hellman}). Verifica infine il certificato ottenuto dal \textit{server} verificando che il server è colui che ha richiesto il certificato. A questo punto l'\textit{handshake} da entrambe le parti è completato, ora è possibile iniziare a scambiare dati cifrati tramite il protocollo stabilito.
        \item 
    \end{enumerate}
    \subsection{\texttt{TLS} \textit{cipher suites}}
        \label{subsec:TLSciphersuites}
        Una cosi detta \textit{cipher suites} è un insieme di algoritmi che permettono di rendere sicura una connessione sulla rete, questa è composta da: un algoritmo di scambio di chiave, un algoritmo di cifratura di massa e un \texttt{MAC} (o \textit{Message Authentication Code}) per permettere l'autenticazione dei messaggi scambiati tra client e server. Le \textit{cipher suites} possono includere \textbf{firme} e \textbf{autenticazioni} per garantire l'autenticazione tra \textit{client} e \textit{server}.
        \paragraph{Nomenclatura} É presente una serie di regole per denominare una \textit{cipher suite}, una di queste è:\newline
        \texttt{TLS\_ECDHE\_RSA\_WITH\_AES\_128\_GCM\_SHA256} ovvero:\begin{description}
            \item[\texttt{TLS}] - Protocollo di sicurezza.
            \item[\texttt{ECDHE\_RSA}] - Algoritmo di scambio di chiave.\begin{description}
                \item[\texttt{ECDHE}] - \textit{Elliptic Curve Diffie-Hellman Ephemeral} in modo che una chiave di sessione sia diversa per ogni sessione, ma con una chiave più piccola.
                \item[\texttt{RSA}] - Algoritmo per i certificati di firma digitale.\footnote{Vedi \ref{subsubsec:RSA} \nameref{subsubsec:RSA}}
            \end{description}   
            \item[\texttt{WITH}] - Separatore.
            \item[\texttt{AES\_128\_GCM}] - Algoritmo di cifratura di massa.\begin{description}
                \item[\texttt{AES}] - \textit{Advanced Encryption Standard}\footnote{Vedi \ref{par:AES} \nameref{par:AES}}.
                \item[\texttt{128}] - Lunghezza della chiave.
                \item[\texttt{GCM}] - \textit{Galois/Counter Mode} è una modalità di cifratura che combina la cifratura con il calcolo di un \texttt{MAC}. Senza di questo il messaggio cifrato solo con \texttt{AES} potrebbe essere comunque visibile.
            \end{description}
        \end{description}
    \subsection{Sulle chiavi \textit{pre-master} \& \textit{master}}
        Durante il processo di \textit{handshake} non viene scambiata la chiave vera e propria, ma una chiave \textit{pre-master}, generata tenendo in mente la \textit{cipher suite} scelta. Per semplificare il processo di generazione delle chiavi è importante identificare una lunghezza fissata per la chiave dalla quale bisogna derivare la chiave \textit{master}, solitamente $ 48 $ byte. La chiave \textit{master} è generata a partire dalla chiave \textit{pre-master} (scambiata durante il \textit{handshake}) e da altri parametri. La chiave \textit{master} è usata per generare le chiavi di sessione che verranno usate per cifrare e decifrare i dati scambiati tra client e server durante la connessione. Il principio dietro questo apparente complicato processo è quello di non usare le stesse chiavi per firmare e autenticate i messaggi, in modo che se una chiave viene compromessa non vengano compromesse entrambe e la controparte è in grado di riconoscere che la chiave è stata compromessa.
    \subsection{In a nutshell}
        Esistono due situazione, quello nel quale solo il \textit{server} si autentica, in questo caso non è possibile distinguere chi sia il \textit{client}, in un secondo caso entrambe le parti si autenticano, in questo caso è possibile distinguere chi sia il \textit{client} e chi il \textit{server}, ciò avviene mediante l'uso di certificati digitali. 
\section{Vulnerabilità di \texttt{TLS}}
    \paragraph{Introduzione} Anche se \texttt{TLS} è uno dei protocolli di sicurezza più utilizzati per garantire la riservatezza, l'integrità e l'autenticità delle comunicazioni su Internet, è comunque soggetto a diverse vulnerabilità che possono essere sfruttate dagli attaccanti per compromettere la sicurezza delle comunicazioni. Le principali cause di queste vulnerabilità sono legate alla compatibilità con versioni obsolete del protocollo, delle "\textit{logical flaws}" ovvero errori logici (sia \textit{client} che \textit{server}), e delle vulnerabilità legate all'implementazione del protocollo (incluso il largamente usato \texttt{OpenSSL}).
    \subsection{Principali vulnerabilità}
    Una delle principali vulnerabilità di \texttt{TLS} è costituita dal fatto che fino a quando il \textit{handshake} non è completato, i dati scambiati tra \textit{client} e \textit{server} non sono protetti e possono essere intercettati da un attaccante, quindi tutti possono vedere che un determinato \textit{client} si sta connettendo a un determinato \textit{server}. Inoltre esistono diverse vulnerabilità legate all'implementazione di \texttt{TLS}, tra cui: \begin{itemize}
        \item \textbf{Heartbleed} - Una vulnerabilità che permette di leggere la memoria del server e di ottenere informazioni sensibili, come le chiavi private e i certificati digitali, causato dalla mancanza di controlli sulla dimensione dei dati inviati al server.
        \item \textbf{RC4NOMORE} - Una vulnerabilità che permette di decifrare alcune parti del flusso chiave di dati cifrati con l'algoritmo \texttt{RC4} (usato vastamente fino al 2017). Già dal 2013 si era iniziato a vedere delle possibili debolezze dell'algoritmo e nel 2015 si sono scoperti dei \textit{bias} sulla generazione del \textit{cipher stream}, fino a quando nel 2017 è stato possibile decifrare delle parti del flusso contenente cookies (e quindi token di autenticazione) permettendo di impersonare un utente. Per un attacco medio di questo genere si impiegano in media $52$ ore in quanto un attaccante deve raccogliere la prima richiesta e calcolare una serie di \textit{cookies} fittizi per impersonare l'utente.
    \end{itemize}
    \subsection{Consolidamento della chiave \& attacchi collegati}
        \paragraph{Overview} Nel processo di \texttt{ClientHello} viene offerta una serie di \textit{cipher suites} che il \textit{client} supporta, il \textit{server} risponde con una \textit{cipher suite} scelta tra quelle offerte dal \textit{client}. Durante \texttt{ClientHello} e \texttt{ServerHello} vengono scambiati anche $32$ byte di dati casuali ($28$ casuali e $4$ di timestamp). Questi dati casuali vengono firmati dal \textit{server} nella \textit{suite} di tipo \textit{Diffie-Hellman} e servono per generare la chiave di sessione. Questi dati casuali sono importanti per garantire la sicurezza della connessione, in quanto permettono di generare una chiave di sessione diversa per ogni sessione, rendendo più difficile per un attaccante intercettare e decifrare i dati scambiati tra \textit{client} e \textit{server}.
        \paragraph{L'attacco} Un attacco cerca di "indurre" il \textit{server} e il \textit{client} ad usare la stessa chiave di sessione. Questo attacco prevede che il male intenzionato ritrasmetta i dati casuali di una precedente sessione della quale si conosce la chiave di sessione, in modo che venga generata la stessa chiave di sessione per la nuova. In questo attacco dunque chi lo esegue deve piazzarsi in mezzo, conoscere una chiave di sessione firmata e riuscire a farla usare al \textit{client}, una volta che si riesce ad intercettare un \textit{token} di autenticazione il gioco è fatto e l'attaccante può impersonare il \textit{client}, per questo è necessario per proteggersi un secondo livello di autenticazione (come una \texttt{OTP}).
    \subsection{Attacchi legati alla retro compatibilità}
        \paragraph{Overview} Un'altra vulnerabilità di \texttt{TLS} è legata alla retro compatibilità con versioni obsolete del protocollo, che possono essere sfruttate dagli attaccanti per compromettere la sicurezza delle comunicazioni. Queste vulnerabilità sono legate alla presenza di \textit{fallback} a versioni meno sicure del protocollo, che possono essere sfruttate dagli attaccanti per compromettere la sicurezza delle comunicazioni.
        \paragraph{L'attacco (\texttt{POODLE})} Un attacco di tipo \texttt{POODLE} (\textit{Padding Oracle On Downgraded Legacy Encryption}) sfrutta la retro compatibilità di \texttt{TLS} con versioni obsolete del protocollo, come \texttt{SSL 3.0}, per compromettere la sicurezza delle comunicazioni. L'attacco sfrutta una vulnerabilità conosciuta del protocollo \texttt{SSL 3.0}, che permette di decifrare i dati scambiati tra \textit{client} e \textit{server} e di ottenere informazioni sensibili, come le chiavi private e i certificati digitali. L'attacco funziona in questo modo: l'attaccante intercetta le prime fasi del \textit{handshake} tra \textit{client} e \textit{server} sostituendosi a quest'ultimo quando il \textit{client} propone una versione di \texttt{TLS} più recente l'attaccante risponde che non supporta quella versione e il \textit{client} retrocede fino a \texttt{SSL 3.0}, a questo punto la comunicazione viene lasciata passare al \textit{server} e l'attaccante può iniziare a decifrare i dati scambiati tra \textit{client} e \textit{server}.
        \paragraph{L'attacco \textit{Bleichenbacher} \& \texttt{ROBOT}} Nel 1998 \textit{Bleichenbacher} ha scoperto una vulnerabilità del tipo \textit{man-in-the-middle} della criptografia basata su \texttt{RSA} che permette di risalire alla chiave \textit{pre-master} e quindi di derivare la chiave di sessione. In questo attacco la debolezza sta nelle risposte del \textit{server} ad un \textit{cipher-text} con un \textit{padding} non corretto, in questo modo l'attaccante può indovinare la chiave \textit{pre-master} quando il server risponde con un \textit{padding} corretto. Il protocollo \texttt{TLS} risolve questo problema in modo che il \textit{server} risponda nella stessa maniera sia che il \textit{padding} sia corretto che non, in modo che l'attaccante non possa indovinare la chiave \textit{pre-master}. Questa vulnerabilità è strettamente collegata all'attacco \texttt{ROBOT} che sfrutta la stessa vulnerabilità molti anni dopo quando si è decifrata le risposte affermative/negative del \textit{server}.
    \subsection{Mitigazioni}
        Per mitigare queste vulnerabilità è necessario adottare alcune misure di sicurezza, tra cui: \begin{itemize}
            \item \textbf{Disabilitare le versioni obsolete del protocollo} - Disabilitare le versioni obsolete del protocollo, come \texttt{SSL 3.0}, per evitare che gli attaccanti possano sfruttare le vulnerabilità di queste versioni per compromettere la sicurezza delle comunicazioni.
            \item \textbf{Usare uno strumento come \texttt{TSLAssistant}} - Uno strumento che permette di identificare le possibili vulnerabilità di \texttt{TLS} e di adottare le misure di sicurezza necessarie per mitigare questi rischi.
            \item \textbf{Configurare bene i protocolli \texttt{TLS}} - Configurare correttamente i protocolli \texttt{TLS} per garantire la sicurezza delle comunicazioni su Internet.
        \end{itemize}