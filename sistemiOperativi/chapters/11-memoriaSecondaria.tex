\chapter{Gestione della memoria secondaria}

La memoria secondaria è un'area di memoria non volatile, che viene utilizzata per memorizzare i dati in modo permanente. A differenza della memoria principale (\texttt{RAM}), la memoria secondaria non perde i dati quando il computer viene spento e non necessita di un `\textit{refresh}' dei condensatori. Esistono diversi tipi di memoria secondaria, tra cui nastri magnetici, dischi rigidi, unità a stato solido (SSD) e supporti ottici, si rende quindi necessario un sistema di gestione della memoria secondaria per garantire che i dati siano memorizzati e recuperati indipendentemente dalla loro posizione fisica. La gestione della memoria secondaria è un aspetto fondamentale dei sistemi operativi moderni, poiché consente di ottimizzare l'uso delle risorse e migliorare le prestazioni del sistema. In questa sezione, esploreremo i principali aspetti della gestione della memoria secondaria, tra cui la memorizzazione dei dati, l'organizzazione dei file e la gestione dello spazio libero.

\section{Tipologia della memoria secondaria}
    \paragraph{Nastri magnetici}
        I nastri magnetici sono un tipo di memoria secondaria che utilizza un nastro magnetico per memorizzare i dati. Tuttora utilizzati per il backup e l'archiviazione a lungo termine, i nastri magnetici offrono una capacità di memorizzazione elevata a un costo relativamente basso. Tuttavia, la velocità di accesso ai dati è molto più lenta rispetto ad altre forme di memoria secondaria, come i dischi rigidi o gli SSD. Questo non tanto a causa della velocità di lettura e scrittura, quanto per il fatto che i nastri magnetici sono dispositivi sequenziali, il che significa che i dati devono essere letti in un ordine specifico. Di conseguenza, l'accesso casuale ai dati su un nastro magnetico può richiedere molto tempo. A differenza di altre forme di memoria secondaria, i nastri magnetici non seguono uno standard di archiviazione dei file, ma piuttosto un dei formati di archiviazione proprietari all'azienda produttrice. I nastri magnetici sono spesso utilizzati in applicazioni di archiviazione a lungo termine, come il backup dei dati e l'archiviazione di grandi volumi di dati.
    \paragraph{Dischi rigidi}
        I dischi rigidi (HDD) sono un tipo di memoria secondaria che utilizza piatti magnetici rotanti per memorizzare i dati. I dischi rigidi offrono una capacità di memorizzazione elevata e una velocità di accesso ai dati relativamente rapida, rendendoli una scelta popolare per l'archiviazione dei dati. Tuttavia, i dischi rigidi sono più lenti rispetto agli SSD e possono essere soggetti a guasti meccanici a causa delle parti mobili. Le operazioni di lettura e scrittura sui dischi rigidi avvengono tramite testine magnetizzanti che si muovono sopra i piatti rotanti, se si vuole scrivere un `0' o un `1' su un piatto, la testina magnetizza o de-magnetizza una piccola area del piatto. Quando si legge un dato, la testina rileva il campo magnetico presente nell'area del piatto e lo converte in un segnale elettrico. I dischi rigidi sono ampiamente utilizzati nei computer desktop e nei laptop, nonché nei server e nei data center per l'archiviazione di grandi volumi di dati. 
        \subparagraph{Settore}
            Un settore è l'unità di memorizzazione più piccola su un disco rigido. Ogni settore ha una dimensione fissa, solitamente di 512 byte o 4 KB, e contiene un blocco di dati. I settori sono raggruppati in \textit{cluster}, che sono la minima unità di allocazione dei file del sistema operativo. Quando un file viene memorizzato su un disco rigido, viene suddiviso in blocchi di dati che vengono memorizzati in settori e cluster. La dimensione del settore e del cluster può influenzare le prestazioni del disco rigido e l'efficienza dell'archiviazione dei dati.
        \subparagraph{Tempi di accesso}
            I tempi di accesso ai dati su un disco rigido sono influenzati da diversi fattori, tra cui la velocità di rotazione dei piatti, la posizione dei dati sul disco e il tempo necessario per spostare la testina di lettura/scrittura. La velocità di rotazione dei piatti è misurata in giri al minuto (RPM) e può variare da 5400 a 15000 RPM. Viene quindi calcolato il tempo di latenza come segue: \textit{Seek time} + \textit{Latency time} + \textit{Transfer time}. Il \textit{Seek time} è il tempo necessario per spostare la testina di lettura/scrittura sulla posizione corretta del disco, il \textit{Latency time} è il tempo necessario per far ruotare il piatto fino a quando il settore desiderato si trova sotto la testina e il \textit{Transfer time} è il tempo necessario per trasferire i dati dal disco alla memoria principale. La somma di questi tre tempi determina il tempo totale di accesso ai dati su un disco rigido. Parlando di numeri si può dire che un disco rigido da 7200 RPM ha un tempo di \textit{seek} di circa 9 ms, un tempo di latenza di circa 4.16 ms ed il tempo di trasferimento come la somma tra `\textit{disk-to-buffer}' \texttt{1030Mb/s}  e `\textit{buffer-to-CPU}' \texttt{300MB/s}. Quindi il tempo totale di accesso ai dati su un disco rigido da 7200 RPM è di circa 13.16 ms. La maggior parte di questo è dato dal tempo di \textit{seek} e dal tempo di latenza, mentre il tempo di trasferimento è relativamente breve. Tuttavia, i dischi rigidi più veloci, come quelli da 10000 o 15000 RPM, possono ridurre significativamente il tempo totale di accesso ai dati.
        \subparagraph{Minimizzazione \textit{seek time}}
            Per minimizzare il tempo di \textit{seek} e migliorare le prestazioni del disco rigido, i sistemi operativi utilizzano diverse tecniche di ottimizzazione. Una di queste tecniche è la \textit{deframmentazione}, che riorganizza i dati sul disco in modo che siano memorizzati in settori contigui. Questo riduce il numero di movimenti della testina di lettura/scrittura e migliora le prestazioni complessive del disco. Un'altra tecnica è la \textit{cache}, che memorizza temporaneamente i dati più frequentemente utilizzati nella memoria principale per ridurre il numero di accessi al disco rigido.
    \paragraph{Unità a stato solido (SSD)}
        Le unità a stato solido (SSD) sono un tipo di memoria secondaria che utilizza memoria flash per memorizzare i dati. Gli SSD offrono una velocità di accesso ai dati molto più rapida rispetto ai dischi rigidi, poiché non hanno parti mobili e possono accedere ai dati in modo casuale. Questi usano delle celle di memoria flash \texttt{NAND}, che sono costituite da transistor a effetto di campo (FET) e memorizzano i dati in forma elettrica. Il costo delle SSD è diminuito negli ultimi anni, rendendole sempre più popolari per l'archiviazione dei dati nei computer e nei dispositivi mobili, ma dischi di grandi dimensioni sono ancora più costosi rispetto agli HDD. Gli SSD sono disponibili in diverse forme e fattori di forma, tra cui unità SATA, unità NVMe e unità M.2. 

\section{\textit{Scheduling} degli accessi al disco}
    Dal punto di vista logico il disco rigido è un dispositivo unidimensionale composto da un insieme di blocchi di memoria detti \textit{cluster}, mentre dal punto di vista fisico è un dispositivo bidimensionale composto da un insieme di cilindri e tracce. Si rende dunque necessario un sistema di \textit{scheduling} per ottimizzare l'accesso ai dati memorizzati su disco. Lo \textit{scheduling} degli accessi al disco è un processo che determina l'ordine in cui le richieste di accesso ai dati vengono elaborate dal disco rigido. Esistono diversi algoritmi di \textit{scheduling} degli accessi al disco, ognuno con i propri vantaggi e svantaggi. Di seguito sono riportati alcuni dei più comuni algoritmi di \textit{scheduling} degli accessi al disco:
    \begin{itemize}
        \item \textbf{FCFS (First-Come, First-Served)}: Questo algoritmo elabora le richieste di accesso ai dati nell'ordine in cui arrivano. Sebbene sia semplice da implementare, può portare a tempi di attesa elevati se ci sono richieste di accesso lontane tra loro.
        \item \textbf{SSTF (Shortest Seek Time First)}: Questo algoritmo elabora le richieste di accesso ai dati in base alla distanza dalla posizione corrente della testina di lettura/scrittura. In questo modo si riduce il tempo di \textit{seek}, ma può portare a un fenomeno noto come minimo locale \textit{starvation}, in cui alcune richieste di accesso ai dati possono rimanere in attesa per un lungo periodo di tempo se ci sono sempre richieste più vicine alla testina.
        \item \textbf{SCAN} (ascensore): Questo algoritmo muove la testina di lettura/scrittura in una direzione (ad esempio, verso l'esterno del disco) e soddisfa tutte le richieste di accesso ai dati lungo il percorso. Una volta raggiunta la fine del disco, la testina torna indietro e soddisfa le richieste rimanenti. Questo algoritmo è più equo rispetto al SSTF, ma può comunque portare a tempi di attesa elevati per alcune richieste.
        \item \textbf{C-SCAN (Circular SCAN)} (spazzaneve): Questo algoritmo è simile al SCAN, ma quando la testina raggiunge la fine del disco, torna all'inizio senza elaborare le richieste lungo il percorso. Questo garantisce che tutte le richieste siano elaborate in modo equo e riduce i tempi di attesa per le richieste lontane dalla posizione corrente della testina.
        \item \textbf{C-LOOK} (spazzaneve circolare): Questo algoritmo è simile al C-SCAN, ma la testina non raggiunge la fine del disco prima di tornare all'inizio. Invece, si sposta solo fino alla richiesta più lontana nella direzione corrente e poi torna all'inizio. Questo riduce ulteriormente i tempi di attesa per le richieste lontane dalla posizione corrente della testina.
        \item \textbf{N-step SCAN}: Questo algoritmo è una variante del SCAN che consente di elaborare delle code diverse di richieste di accesso ai dati. In questo modo, le richieste vengono suddivise in gruppi di dimensioni fisse e ogni gruppo viene elaborato in modo indipendente. Quando un gruppo è completo questo viene elaborato in modo simile al SCAN, ma le richieste all'interno del gruppo possono essere elaborate in qualsiasi ordine. Questo algoritmo può migliorare le prestazioni del disco rigido e ridurre i tempi di attesa per le richieste di accesso ai dati.
    \end{itemize}
    In generale nessun algoritmo di \textit{scheduling} degli accessi al disco è perfetto e la scelta dell'algoritmo dipende dalle esigenze specifiche del sistema e dalle caratteristiche delle richieste di accesso ai dati. Tuttavia, gli algoritmi di \textit{scheduling} degli accessi al disco possono migliorare significativamente le prestazioni del disco rigido e ridurre i tempi di attesa per le richieste di accesso ai dati.

\section{Gestione del disco}
    \paragraph{Formattazione}
        La formattazione di basso livello (o fisica) è il processo di preparazione di un disco rigido o di un altro dispositivo di memorizzazione per l'uso. Durante la formattazione, il disco viene suddiviso in settori e tracce, creando una struttura logica per l'archiviazione dei dati. La formattazione fisica aggiunge inoltre lo spazio di correzione degli errori (\texttt{ECC}). Viene anche caricato sulk disco il \textit{boot sector}, che contiene le informazioni necessarie per avviare il sistema operativo. \newline
        La formattazione di alto livello (o logica) è il processo di creazione di un file system sul disco. Durante la formattazione logica, il disco viene suddiviso in partizioni e viene creato un file system che consente al sistema operativo di gestire i file e le directory. La formattazione logica crea anche una tabella di allocazione dei file (FAT) o un inode, che tiene traccia dei file memorizzati sul disco e delle loro posizioni fisiche. La formattazione logica può essere eseguita su un disco già formattato fisicamente, ma non è necessario eseguire la formattazione fisica ogni volta che si formatta un disco.
    \paragraph{Gestione blocchi difettosi}
        Come anticipato in precedenza, i dischi rigidi e gli SSD oltre a memorizzare i dati, memorizzano anche informazioni di correzione degli errori. Solitamente viene calcolato un \texttt{ECC} il quale viene memorizzato alla fine del settore e viene utilizzato per verificare l'integrità dei dati memorizzati. Se quando agiamo in lettura su un settore, dopo il calcolo del \texttt{ECC} il risultato non è corretto, il settore viene considerato difettoso. Per gestire i \textit{bad block} vengono usate o tecniche \textit{off-line} quali individuazione al momento di formattazione con rimozione e/o marcatura nella \texttt{FAT}, utilità come \texttt{chkdsk} o \texttt{fsck} o tecniche \textit{on-line} quali la mappatura dei settori difettosi in settori di riserva. In questo caso i settori di riserva devono essere riservati in fase di formattazione e non devono essere utilizzati per memorizzare i dati, inoltre questi settori devono essere presenti su ogni cilindro del disco in modo da ridurre il tempo di \textit{seek}.
    \paragraph{Interfacce di connessione}
        Le interfacce di connessione sono i protocolli e le tecnologie utilizzate per collegare i dispositivi di memorizzazione al computer. Esistono diverse interfacce di connessione, tra cui:
        \begin{itemize}
            \item \textbf{SATA (Serial Advanced Technology Attachment)}: Questa è una delle interfacce di connessione più comuni per i dischi rigidi e gli SSD. SATA offre velocità di trasferimento dati elevate e supporta la connessione di più dispositivi a un singolo controller. Le versioni più recenti di SATA, come SATA III, offrono velocità di trasferimento dati fino a 6 Gbps.
            \item \textbf{IDE (Integrated Drive Electronics)}: Questa è un'interfaccia di connessione più vecchia rispetto a SATA usa trasmissione parallela e supporta solo un numero limitato di dispositivi. IDE è stato ampiamente utilizzato nei computer desktop e nei laptop, ma è stato gradualmente sostituito da SATA.
        \end{itemize}
    \paragraph{Gestione spazio di \textit{swap}}
        Il sistema operativo potrebbe decidere di adottare una sezione della memoria secondaria per estendere la memoria principale (vedi capitolo precedente). Per farlo viene o presa una normale sezione dal \textit{file system}, il che può risultare inefficiente, oppure viene creata una partizione dedicata. In questo caso viene risparmiato spazio in quanto non devono essere memorizzati i dati di \textit{file system}, questa è la soluzione più comune. 