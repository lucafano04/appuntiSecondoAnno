\chapter{File System}

Il \textit{file system} fornisce il meccanismo fondamentale per la memorizzazione e l'accesso ai dati e ai programmi su un computer. Esso consiste nella collezione di file e nella struttura che li organizza. 

\section{L'interfaccia del \textit{file system}}
    \paragraph{File} Il file è l'astrazione logica per accedere ai supporti di memorizzazione. Un file è costituito da uno spazio di indirizzamento logico e contiguo e raggruppa un insieme di informazioni identificate da un nome.
    \paragraph{Attributi di un file} Ogni file è caratterizzato da un insieme di attributi, che non sono propriamente parte del file, ma sono informazioni memorizzate nel \textit{file system} e associate al file. Gli attributi di un file sono:
    \begin{itemize}
        \item Il nome del file
        \item Il tipo di file
        \item La posizione del file (nella memoria secondaria)
        \item La dimensione del file 
        \item L'eventuale protezione del file (permessi di accesso)
        \item La data di creazione, modifica e accesso
    \end{itemize}
    \paragraph{Operazioni sui file} Le operazioni fondamentali che possono essere eseguite su un file sono:
    \begin{itemize}
        \item Creazione - Si crea uno spazio sul disco per il file e si memorizzano gli attributi del file.
        \item Scrittura - Si usano delle \textit{system call} per scrivere i dati nel file, conoscendo il puntatore alla posizione del file e della prossima scrittura.
        \item Lettura - Si usano delle \textit{system call} per leggere i dati dal file, conoscendo il puntatore alla posizione del file e della prossima lettura.
        \item Riposizionamento - Si usano delle \textit{system call} per modificare il puntatore alla posizione del file.
        \item Eliminazione - Si eliminano gli attributi del file e si libera lo spazio occupato dal file.
        \item Troncamento - Si accorcia il file, eliminando i dati oltre una certa posizione.
        \item Apertura - Si cerca nella struttura del \textit{file system} il file e si copia il file nella memoria principale e si inserisce un riferimento al file aperto nella tabella dei file aperti.
        \item Chiusura - Si elimina il riferimento, si salvano eventuali modifiche e si libera lo spazio occupato dal file aperto.
    \end{itemize}
    \paragraph{Struttura di un file} Il tipo di un file ne può definire la struttura, nei sistemi linux i file sono semplicemente sequenze di byte, mentre in altri sistemi operativi i file possono essere strutturati come ``record'' semplici oppure tramite strutture più complesse, gli ultimi due casi possono essere in alcuni casi emulati tramite il primo caso.
    \paragraph{Metodi di accesso} I metodi di accesso ai file sono:
    \subparagraph{Accesso sequenziale} I dati sono letti in modo sequenziale, il puntatore alla posizione del file viene spostato automaticamente alla fine del file dopo la lettura. In questo caso le operazioni consentite sono: \textit{read next}, \textit{write next}, \textit{reset}. Non è permessa l'operazione di \textit{rewrite} dato che c'è il rischio di sovrascrivere i dati.
    \subparagraph{Accesso diretto} I dati sono letti in modo diretto, come in un database, il puntatore alla posizione del file viene spostato automaticamente alla fine del file dopo la lettura. In questo caso le operazioni consentite sono: \textit{read}, \textit{write}, \textit{position to }, \textit{read next}, \textit{write next}, \textit{rewrite}.
\section{Struttura delle \textit{directory}}
    Ogni partizione di disco è organizzata in due zone di memoria: la prima contiene le informazioni sulle directory e la seconda contiene i file. Andando ora ad analizzare la struttura delle directory, possiamo astrarre questa come una collezione di nodi che contengono le informazioni sui file (viste sopra) e che sono organizzati in una struttura ad albero. 
    \paragraph{Operazioni sulle directory} Le operazioni fondamentali che possono essere eseguite su una directory sono:
    \begin{itemize}
        \item Aggiunta di un file - Si crea un nuovo nodo nella directory e si memorizzano gli attributi del file.
        \item Cancellazione di un file - Si elimina il nodo dalla directory e si libera lo spazio occupato dal file.
        \item Visualizzazione - Si visualizzano i nodi della directory.
        \item Rinominare un file - Si modificano gli attributi del file.
        \item Ricercare un file - Si cerca il nodo nella directory e si restituisce il puntatore al file, eventualmente si cerca anche nelle sottodirectory.
        \item Attraversare il \textit{file system} - Si attraversa il \textit{file system} a partire dalla directory corrente, si possono usare le operazioni di \textit{cd}, \textit{ls}, \textit{pwd} per spostarsi tra le directory e visualizzare i file.
    \end{itemize}
    \subsubsection{Organizzazione logica delle directory} L'organizzazione logica delle directory è stata sviluppata tenendo conto di tre obbiettivi: l'efficienza, l'accesso ad un file deve essere veloce, la nomenclatura, i nomi dei file devono essere univoci per lo stesso utente ma possono essere duplicati per utenti diversi oltre a più nomi per lo stesso file, e il raggruppamento, i file devono essere raggruppati in modo logico.
        \paragraph{Directory ad un livello} In questo caso esiste una sola directory per tutti gli utenti, i file sono identificati da un nome univoco. Questo metodo è poco usato in quanto sussistono problemi di nomenclatura e di raggruppamento.
        \paragraph{Directory a più livelli} In questo caso ogni utente ha una sua directory, i file sono identificati da un nome univoco per ogni utente. Viene introdotti il concetto di ``\textit{path}'' che è una sequenza di nomi di directory che portano al file. Rispetto al caso precedente, questo metodo permette di usare lo stesso nome per file diversi ed migliora la ricerca dei file, ma non risolve il problema di raggruppamento. Inoltre i programmi di sistema per essere condivisi tra più utenti devono essere memorizzati in una directory comune e per tenerne traccia si usano i puntatori simbolici, in linux si usa la \textit{directory} \texttt{PATH} per memorizzare i puntatori simbolici.
        \paragraph{Directory ad albero} Questo metodo è una evoluzione del metodo a più livelli, in questo caso ogni directory può contenere altre directory, formando una struttura ad albero. In questo modo si risolve il problema di raggruppamento e si migliora la ricerca dei file. Viene introdotto il concetto di ``\textit{directory corrente}'' che è la directory in cui ci si trova al momento e che viene usata come punto di partenza per le operazioni di ricerca. Inoltre viene introdotto il concetto di percorso assoluto e relativo, il primo è un percorso che parte dalla radice dell'albero, mentre il secondo è un percorso che parte dalla directory corrente.
        \paragraph{Directory a grafo aciclico} Questo metodo è una evoluzione del metodo ad albero, in questo caso un file può essere ``referenziato'' da più directory, formando una struttura a grafo aciclico. In questo modo si implementa una prima condivisione dei file tra più utenti, ma si introduce il problema di eliminazione dei file, in quanto se un file è referenziato da più directory, la sua eliminazione deve essere gestita in modo da non lasciare puntatori a file non esistenti. Per risolvere questo problema si usano i puntatori simbolici, che sono dei puntatori a file che possono essere eliminati senza eliminare il file stesso. Esistono due tipi di puntatori, i link simbolici e gli \textit{hard link}, i primi sono dei puntatori a file che possono essere eliminati senza eliminare il file stesso, questi contengono il nome vero del file e se il questo viene eliminato, il puntatore simbolico diventa un ``link rotto'', mentre gli \textit{hard link} sono dei contatori che contengono il numero di puntatori a file, quando si elimina uno di questi, il contatore viene decrementato e il file viene eliminato solo quando il contatore arriva a zero. 
        \paragraph{Directory a grafo} Questo metodo è una evoluzione del metodo a grafo aciclico, in questo caso anche le \textit{directory} possono essere referenziate da più \textit{directory}, formando una struttura a grafo, che eventualmente contengono dei cicli, in questo caso bisogna gestire queste situazioni nel caso della ricerca di un file, in quanto si potrebbe entrare in un ciclo infinito. Per risolvere questo problema alcuni \texttt{fs} permettono i soli collegamenti tra file mentre altri effettuano dei controlli per evitare i cicli.
    
    \paragraph{\textit{Mount} di un \textit{file system}} Il \textit{mount} di un \textit{file system} è l'operazione che permette di rendere questo modulare permettendo di attaccare e staccare i \textit{file system} in altri \textit{file system} già montati. Bisogna definire un punto di attacco, che è una directory in cui viene montato il \textit{file system} (\textit{mount point}). Uno stesso \textit{file system} può essere montato in più punti di attacco, da \textit{file system} diversi, può essere quindi condiviso tra più utenti anche su dispositivi diversi.
    \paragraph{Condivisione di file} La condivisione di file è un'operazione che permette di condividere file tra più utenti, in questo modo si possono usare gli stessi file senza doverli copiare e tenerne manualmente traccia. Per implementare ciò, però, è necessario implementare prima dei meccanismi di protezione. Il \textit{file system} più usato per la condivisione di file è il \textit{Network File System} che permette la condivisione tramite la rete.
    \paragraph{Protezione} Il proprietario di un file deve essere in grado di gestire le operazioni eseguibili su questo. In alcuni sistemi obsoleti veniva usata una matrice dei permessi, in sistemi moderni viene usata o la più compatta lista di accesso (Windows) o la divisione degli utenti in tre classi (\textit{user, group, others})
\section{Implementazione del File system}
    La memoria secondaria è organizzata a livelli, infatti si parte del controllore di \texttt{I/O} che gestisce i dispositivi di memorizzazione per poi passare al \textit{basic file system} che gestisce le primitive di \texttt{R/W} sui singoli blocchi di memoria, a seguire il \textit{file organization module} che gestisce i file e le directory, infine il \textit{logical file system} che gestisce le operazioni sui file e le directory. Ogni livello ha una sua interfaccia e comunica con il livello sottostante tramite delle \textit{system call}. 
    \paragraph{Strutture dati}
        Per gestire questo complesso sistema vengono usate diverse strutture dati, alcune memorizzate in memoria principale e altre memorizzate su disco, queste dipendono strettamente dal tipo di \textit{file system} e dal tipo di \texttt{SO} ma esistono delle strutture generali che vengono usate in tutti i \textit{file system}: su disco possiamo trovare infatti il blocco di boot, che contiene le informazioni necessarie per l'avvio del \texttt{SO}, il blocco di controllo delle partizioni, che contiene le informazioni sulle partizioni del disco, la struttura delle directory, che contiene le informazioni sui file e le directory, i descrittori di file, che contengono le informazioni sui file e puntatori a blocchi di dati. Sulla memoria principale troviamo invece la tabella dei file partizioni, struttura della directory, replicate entrambe dalla memoria secondaria, la tabella globale dei file aperti, che contiene i puntatori ai file descriptor e la tabella dei file aperti per processo che contiene i puntatori ai file aperti per ogni processo.
    \subsubsection{Allocazione dello spazio su disco}
        Quando si crea un file, il \textit{file system} deve allocare lo spazio necessario per memorizzare i dati del file. Esistono diversi metodi di allocazione dello spazio su disco, ognuno con i suoi vantaggi e svantaggi.
        \paragraph{Allocazione contigua} In questo metodo, lo spazio per il file viene allocato in modo contiguo, ovvero i blocchi di dati del file sono memorizzati in posizioni contigue sul disco. Questo metodo permette di memorizzare i file conoscendone solo la posizione iniziale e la dimensione, ma si verifica il problema della frammentazione, ovvero la divisione dello spazio su disco in piccole porzioni non utilizzabili. Inoltre, questo metodo non permette di estendere i file in certe situazioni, in quanto non è possibile allocare spazio contiguo per il file.
        \paragraph{Allocazione a lista} In questo metodo, si tene traccia del punto di inizio del file e del punto di fine del file, andando a memorizzare su ogni singolo blocco di dati del file il puntatore al blocco successivo, se presente. Questo metodo permette di allocare lo spazio in modo non contiguo, ma richiede più spazio per memorizzare i puntatori e non garantisce un accesso casuale ai dati. Inoltre si perde completamente la località dei dati, in quanto i blocchi di dati possono essere memorizzati in posizioni non contigue sul disco.
        \paragraph{Allocazione a lista - variante extent} In questo metodo, viene usata la stessa idea del metodo a lista, ma al posto di memorizzare in blocchi di dati in posizione casuale si memorizzano in blocchi di dati contigui finché possibile. In questo modo si riesce a mantenere una quasi contiguità e località dei dati, e si continua a memorizzare i puntatori ai blocchi di dati. 
            \subparagraph{Esempio \texttt{FAT}} Un esempio di allocazione a lista è il \texttt{FAT} (File Allocation Table), che è una tabella che tiene traccia dei blocchi di dati allocati per ogni file. Ogni file ha un puntatore al primo blocco di dati e ogni blocco di dati ha un puntatore al blocco successivo. Il limite di questo metodo è dato dalla dimensione di ogni \textit{entry} della tabella, che può essere di 12, 16 o 32 bit, a seconda della dimensione del disco. Se questa è ad esempio di 32 bit allora si potranno allocare fino a 2\textsuperscript{32} blocchi di dati, che corrispondono a 4 GB di spazio su disco. Questo metodo è stato usato in passato per i dischi rigidi e le memorie flash, ma è stato superato da metodi più moderni. (\texttt{NTFS} e \texttt{exFAT} sono i successori del \texttt{FAT}).