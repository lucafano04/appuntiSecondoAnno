\chapter{File System}

Il \textit{file system} fornisce il meccanismo fondamentale per la memorizzazione e l'accesso ai dati e ai programmi su un computer. Esso consiste nella collezione di file e nella struttura che li organizza. 

\section{L'interfaccia del \textit{file system}}
    \paragraph{File} Il file è l'astrazione logica per accedere ai supporti di memorizzazione. Un file è costituito da uno spazio di indirizzamento logico e contiguo e raggruppa un insieme di informazioni identificate da un nome.
    \paragraph{Attributi di un file} Ogni file è caratterizzato da un insieme di attributi, che non sono propriamente parte del file, ma sono informazioni memorizzate nel \textit{file system} e associate al file. Gli attributi di un file sono:
    \begin{itemize}
        \item Il nome del file
        \item Il tipo di file
        \item La posizione del file (nella memoria secondaria)
        \item La dimensione del file 
        \item L'eventuale protezione del file (permessi di accesso)
        \item La data di creazione, modifica e accesso
    \end{itemize}
    \paragraph{Operazioni sui file} Le operazioni fondamentali che possono essere eseguite su un file sono:
    \begin{itemize}
        \item Creazione - Si crea uno spazio sul disco per il file e si memorizzano gli attributi del file.
        \item Scrittura - Si usano delle \textit{system call} per scrivere i dati nel file, conoscendo il puntatore alla posizione del file e della prossima scrittura.
        \item Lettura - Si usano delle \textit{system call} per leggere i dati dal file, conoscendo il puntatore alla posizione del file e della prossima lettura.
        \item Riposizionamento - Si usano delle \textit{system call} per modificare il puntatore alla posizione del file.
        \item Eliminazione - Si eliminano gli attributi del file e si libera lo spazio occupato dal file.
        \item Troncamento - Si accorcia il file, eliminando i dati oltre una certa posizione.
        \item Apertura - Si cerca nella struttura del \textit{file system} il file e si copia il file nella memoria principale e si inserisce un riferimento al file aperto nella tabella dei file aperti.
        \item Chiusura - Si elimina il riferimento, si salvano eventuali modifiche e si libera lo spazio occupato dal file aperto.
    \end{itemize}
    \paragraph{Struttura di un file} Il tipo di un file ne può definire la struttura, nei sistemi linux i file sono semplicemente sequenze di byte, mentre in altri sistemi operativi i file possono essere strutturati come ``record'' semplici oppure tramite strutture più complesse, gli ultimi due casi possono essere in alcuni casi emulati tramite il primo caso.
    \paragraph{Metodi di accesso} I metodi di accesso ai file sono:
    \subparagraph{Accesso sequenziale} I dati sono letti in modo sequenziale, il puntatore alla posizione del file viene spostato automaticamente alla fine del file dopo la lettura. In questo caso le operazioni consentite sono: \textit{read next}, \textit{write next}, \textit{reset}. Non è permessa l'operazione di \textit{rewrite} dato che c'è il rischio di sovrascrivere i dati.
    \subparagraph{Accesso diretto} I dati sono letti in modo diretto, come in un database, il puntatore alla posizione del file viene spostato automaticamente alla fine del file dopo la lettura. In questo caso le operazioni consentite sono: \textit{read}, \textit{write}, \textit{position to }, \textit{read next}, \textit{write next}, \textit{rewrite}.
\section{Struttura delle \textit{directory}}
    Ogni partizione di disco è organizzata in due zone di memoria: la prima contiene le informazioni sulle directory e la seconda contiene i file. Andando ora ad analizzare la struttura delle directory, possiamo astrarre questa come una collezione di nodi che contengono le informazioni sui file (viste sopra) e che sono organizzati in una struttura ad albero. 
    \paragraph{Operazioni sulle directory} Le operazioni fondamentali che possono essere eseguite su una directory sono:
    \begin{itemize}
        \item Aggiunta di un file - Si crea un nuovo nodo nella directory e si memorizzano gli attributi del file.
        \item Cancellazione di un file - Si elimina il nodo dalla directory e si libera lo spazio occupato dal file.
        \item Visualizzazione - Si visualizzano i nodi della directory.
        \item Rinominare un file - Si modificano gli attributi del file.
        \item Ricercare un file - Si cerca il nodo nella directory e si restituisce il puntatore al file, eventualmente si cerca anche nelle sottodirectory.
        \item Attraversare il \textit{file system} - Si attraversa il \textit{file system} a partire dalla directory corrente, si possono usare le operazioni di \textit{cd}, \textit{ls}, \textit{pwd} per spostarsi tra le directory e visualizzare i file.
    \end{itemize}
    \subsubsection{Organizzazione logica delle directory} L'organizzazione logica delle directory è stata sviluppata tenendo conto di tre obbiettivi: l'efficienza, l'accesso ad un file deve essere veloce, la nomenclatura, i nomi dei file devono essere univoci per lo stesso utente ma possono essere duplicati per utenti diversi oltre a più nomi per lo stesso file, e il raggruppamento, i file devono essere raggruppati in modo logico.
        \paragraph{Directory ad un livello} In questo caso esiste una sola directory per tutti gli utenti, i file sono identificati da un nome univoco. Questo metodo è poco usato in quanto sussistono problemi di nomenclatura e di raggruppamento.
        \paragraph{Directory a più livelli} In questo caso ogni utente ha una sua directory, i file sono identificati da un nome univoco per ogni utente. Viene introdotti il concetto di ``\textit{path}'' che è una sequenza di nomi di directory che portano al file. Rispetto al caso precedente, questo metodo permette di usare lo stesso nome per file diversi ed migliora la ricerca dei file, ma non risolve il problema di raggruppamento. Inoltre i programmi di sistema per essere condivisi tra più utenti devono essere memorizzati in una directory comune e per tenerne traccia si usano i puntatori simbolici, in linux si usa la \textit{directory} \texttt{PATH} per memorizzare i puntatori simbolici.
        \paragraph{Directory ad albero} Questo metodo è una evoluzione del metodo a più livelli, in questo caso ogni directory può contenere altre directory, formando una struttura ad albero. In questo modo si risolve il problema di raggruppamento e si migliora la ricerca dei file. Viene introdotto il concetto di ``\textit{directory corrente}'' che è la directory in cui ci si trova al momento e che viene usata come punto di partenza per le operazioni di ricerca. Inoltre viene introdotto il concetto di percorso assoluto e relativo, il primo è un percorso che parte dalla radice dell'albero, mentre il secondo è un percorso che parte dalla directory corrente.
        \paragraph{Directory a grafo aciclico} Questo metodo è una evoluzione del metodo ad albero, in questo caso un file può essere ``referenziato'' da più directory, formando una struttura a grafo aciclico. In questo modo si implementa una prima condivisione dei file tra più utenti, ma si introduce il problema di eliminazione dei file, in quanto se un file è referenziato da più directory, la sua eliminazione deve essere gestita in modo da non lasciare puntatori a file non esistenti. Per risolvere questo problema si usano i puntatori simbolici, che sono dei puntatori a file che possono essere eliminati senza eliminare il file stesso. Esistono due tipi di puntatori, i link simbolici e gli \textit{hard link}, i primi sono dei puntatori a file che possono essere eliminati senza eliminare il file stesso, questi contengono il nome vero del file e se il questo viene eliminato, il puntatore simbolico diventa un ``link rotto'', mentre gli \textit{hard link} sono dei contatori che contengono il numero di puntatori a file, quando si elimina uno di questi, il contatore viene decrementato e il file viene eliminato solo quando il contatore arriva a zero. 
        \paragraph{Directory a grafo} Questo metodo è una evoluzione del metodo a grafo aciclico, in questo caso anche le \textit{directory} possono essere referenziate da più \textit{directory}, formando una struttura a grafo, che eventualmente contengono dei cicli, in questo caso bisogna gestire queste situazioni nel caso della ricerca di un file, in quanto si potrebbe entrare in un ciclo infinito. Per risolvere questo problema alcuni \texttt{fs} permettono i soli collegamenti tra file mentre altri effettuano dei controlli per evitare i cicli.
    
    \paragraph{\textit{Mount} di un \textit{file system}} Il \textit{mount} di un \textit{file system} è l'operazione che permette di rendere questo modulare permettendo di attaccare e staccare i \textit{file system} in altri \textit{file system} già montati. Bisogna definire un punto di attacco, che è una directory in cui viene montato il \textit{file system} (\textit{mount point}). Uno stesso \textit{file system} può essere montato in più punti di attacco, da \textit{file system} diversi, può essere quindi condiviso tra più utenti anche su dispositivi diversi.
    \paragraph{Condivisione di file} La condivisione di file è un'operazione che permette di condividere file tra più utenti, in questo modo si possono usare gli stessi file senza doverli copiare e tenerne manualmente traccia. Per implementare ciò, però, è necessario implementare prima dei meccanismi di protezione. Il \textit{file system} più usato per la condivisione di file è il \textit{Network File System} che permette la condivisione tramite la rete.
    \paragraph{Protezione} Il proprietario di un file deve essere in grado di gestire le operazioni eseguibili su questo. In alcuni sistemi obsoleti veniva usata una matrice dei permessi, in sistemi moderni viene usata o la più compatta lista di accesso (Windows) o la divisione degli utenti in tre classi (\textit{user, group, others})
\section{Implementazione del File system}
    La memoria secondaria è organizzata a livelli, infatti si parte del controllore di \texttt{I/O} che gestisce i dispositivi di memorizzazione per poi passare al \textit{basic file system} che gestisce le primitive di \texttt{R/W} sui singoli blocchi di memoria, a seguire il \textit{file organization module} che gestisce i file e le directory, infine il \textit{logical file system} che gestisce le operazioni sui file e le directory. Ogni livello ha una sua interfaccia e comunica con il livello sottostante tramite delle \textit{system call}. 
    \paragraph{Strutture dati}
        Per gestire questo complesso sistema vengono usate diverse strutture dati, alcune memorizzate in memoria principale e altre memorizzate su disco, queste dipendono strettamente dal tipo di \textit{file system} e dal tipo di \texttt{SO} ma esistono delle strutture generali che vengono usate in tutti i \textit{file system}: su disco possiamo trovare infatti il blocco di boot, che contiene le informazioni necessarie per l'avvio del \texttt{SO}, il blocco di controllo delle partizioni, che contiene le informazioni sulle partizioni del disco, la struttura delle directory, che contiene le informazioni sui file e le directory, i descrittori di file, che contengono le informazioni sui file e puntatori a blocchi di dati. Sulla memoria principale troviamo invece la tabella dei file partizioni, struttura della directory, replicate entrambe dalla memoria secondaria, la tabella globale dei file aperti, che contiene i puntatori ai file descriptor e la tabella dei file aperti per processo che contiene i puntatori ai file aperti per ogni processo.
    \subsubsection{Allocazione dello spazio su disco}
        Quando si crea un file, il \textit{file system} deve allocare lo spazio necessario per memorizzare i dati del file. Esistono diversi metodi di allocazione dello spazio su disco, ognuno con i suoi vantaggi e svantaggi.
        \paragraph{Allocazione contigua} In questo metodo, lo spazio per il file viene allocato in modo contiguo, ovvero i blocchi di dati del file sono memorizzati in posizioni contigue sul disco. Questo metodo permette di memorizzare i file conoscendone solo la posizione iniziale e la dimensione, ma si verifica il problema della frammentazione, ovvero la divisione dello spazio su disco in piccole porzioni non utilizzabili. Inoltre, questo metodo non permette di estendere i file in certe situazioni, in quanto non è possibile allocare spazio contiguo per il file.
        \paragraph{Allocazione a lista} In questo metodo, si tene traccia del punto di inizio del file e del punto di fine del file, andando a memorizzare su ogni singolo blocco di dati del file il puntatore al blocco successivo, se presente. Questo metodo permette di allocare lo spazio in modo non contiguo, ma richiede più spazio per memorizzare i puntatori e non garantisce un accesso casuale ai dati. Inoltre si perde completamente la località dei dati, in quanto i blocchi di dati possono essere memorizzati in posizioni non contigue sul disco.
        \paragraph{Allocazione a lista - variante extent} In questo metodo, viene usata la stessa idea del metodo a lista, ma al posto di memorizzare in blocchi di dati in posizione casuale si memorizzano in blocchi di dati contigui finché possibile. In questo modo si riesce a mantenere una quasi contiguità e località dei dati, e si continua a memorizzare i puntatori ai blocchi di dati. 
            \subparagraph{Esempio \texttt{FAT}} Un esempio di allocazione a lista è il \texttt{FAT} (File Allocation Table), che è una tabella che tiene traccia dei blocchi di dati allocati per ogni file. Ogni file ha un puntatore al primo blocco di dati e ogni blocco di dati ha un puntatore al blocco successivo. Il limite di questo metodo è dato dalla dimensione di ogni \textit{entry} della tabella, che può essere di 12, 16 o 32 bit, a seconda della dimensione del disco. Se questa è ad esempio di 32 bit allora si potranno allocare fino a 2\textsuperscript{32} blocchi di dati, che corrispondono a 4 GB di spazio su disco. Questo metodo è stato usato in passato per i dischi rigidi e le memorie flash, ma è stato superato da metodi più moderni. (\texttt{NTFS} e \texttt{exFAT} sono i successori del \texttt{FAT}).
        \paragraph{Allocazione indicizzata} Ogni file è caratterizzato da un blocco indice (\textit{index block}) che contiene la tabella degli indirizzi dei blocchi di dati del file. Viene dunque memorizzato solo l'indirizzo del blocco indice nella \textit{directory}. In questo modo possiamo garantire l'accesso casuale ai dati, ma non la località, ciò in quanto i blocchi di dati possono essere memorizzati in posizioni non contigue sul disco. Inoltre, questo metodo richiede comunque un ulteriore blocco di dati per memorizzare la tabella degli indirizzi, che può essere di dimensioni variabili a seconda della dimensione del file. Inoltre bisogna considerare che la dimensione del blocco indice limita la dimensione del file, in quanto se il file richiede più blocchi di dati di quelli che possono essere memorizzati nel blocco indice. Si potrebbe aumentare la dimensione del blocco indice, ma ciò porterebbe ad un aumento dello ``spreco'' di memoria per tutti i file, in quanto non tutti i file richiedono l'intero blocco indice. Per la traduzione degli indirizzi una volta che si conosce la dimensione del blocco ($N$) e l'indirizzo logico ($X$) allora nella posizione $X/N$ si trova il blocco indice e $X\%N$ è l'\textit{offset} all'interno del blocco indice. Questa traduzione a differenza delle altre viene effettuata tramite \textit{software} e non tramite \textit{hardware}, in quanto questo è un calcolo relativamente semplice e veloce da effettuare.\newline  
        Nei sistemi reali si usano o Indici multi-livello, o lo schema concatenato oppure con lo schema combinato. 
            \subparagraph{Indici multi-livello}  Nell'indicizzazione multi-livello, il blocco indice è memorizzato in più livelli, in modo da poter memorizzare file più grandi rispetto alla dimensione del blocco indice. In questo modo l'indirizzo del blocco indice di primo livello è dato da $X/N^2$, l'indirizzo del blocco indice di secondo livello è dato da $(X\%N^2)/N$ e l'\textit{offset} all'interno del blocco indice è dato da $(X\%N^2)\%N$. Dato che non è detto che vadano memorizzati tutti i blocchi di dati, si usano dei puntatori nulli per indicare i blocchi di dati non allocati, comunque dovremmo allocare almeno un blocco di primo livello ed un blocco di secondo livello.  
            \subparagraph{Schema concatenato} In questo schema la tabella dei file memorizza il puntatore al primo blocco indice, il quale se non è sufficiente a memorizzare gli indirizzi di tutti i blocchi di dati, memorizza nell'ultima posizione un puntatore al blocco indice successivo. Possiamo quindi, in teoria, memorizzare un numero infinito di blocchi di dati, ma in pratica si ha un limite dato dalla dimensione del disco. L'indirizzamento con $X$ l'indirizzo logico ed $N$ la dimensione del blocco, è dato da $X/(N(N-1))$ per il numero di blocco dell'indice e $X\%(N(N-1)) = R$ dove $R/N-1$ è l'offset del blocco indice e $R\%N$ sono gli offset del blocco di dati.
            \subparagraph{Schema combinato - i-node} In questo schema si usano diversi livelli di indici, in modo da poter memorizzare file più grandi rispetto alla dimensione del blocco indice mantenendo comunque un ridotto uso della memoria per i file più piccoli. Nel caso particolare \texttt{UNIX} usa 10 puntatori diretti, 1 puntatore indiretto singolo (1 livello), 1 puntatore indiretto doppio (2 livelli) e 1 puntatore indiretto triplo (3 livelli). I file più grandi vengono memorizzati con livelli più alti di indici, mentre i file più piccoli vengono memorizzati con livelli più bassi di indici. In questo modo si riesce a mantenere un buon compromesso tra spazio e velocità di accesso ai dati.
    \subsubsection{Gestione delle \textit{directory}}
        Lo stesso meccanismo per la memorizzazione dei file viene usato per la memorizzazione delle directory anche se queste non contengono dati, ma solo puntatori a file. In questo modo possono sorgere problematiche sul come questo contenuto viene memorizzato e come viene gestito l'accesso al contenuto della directory. 
        \paragraph{Implementazione con lista di nomi} In questo metodo, la directory è memorizzata come una lista di nomi di file, con i puntatori ai file. Questo metodo è semplice da implementare, ma è poco efficiente sia in lettura che in scrittura e rimozione.
        \paragraph{Implementazione con tabella hash} In questo metodo, la directory è memorizzata come una tabella hash, con i puntatori ai file, il nome del fine viene passato come chiave per la tabella hash. Questo metodo è più efficiente rispetto al metodo precedente, ma richiede più spazio per memorizzare la tabella hash e vanno gestite le collisioni. La tabella hash potrebbe ``sprecare'' spazio per ogni \textit{directory} in quanto non è detto che tutti i puntatori siano usati, ma in questo caso si potrebbe usare una tabella hash con un numero di \textit{entry} maggiore rispetto al numero di file memorizzati nella directory, si devono però gestire le collisioni.


\section{Gestione dello spazio libero}
    La gestione dello spazio libero è un'operazione fondamentale per il \textit{file system}, in quanto permette di tenere traccia dei blocchi di dati liberi e di allocare lo spazio necessario per i file. Esistono diversi metodi per gestire lo spazio libero, ognuno con i suoi vantaggi e svantaggi. In linea generale quando si crea un file si cercano dei blocchi di dati liberi nella struttura dati usata per tenere traccia dello spazio libero, per la rimozione di un file si liberano i blocchi di dati occupati dal file e si aggiornano le strutture dati usate per tenere traccia dello spazio libero.
    \paragraph{Vettore di \texttt{bit}} In questo metodo, si usa un vettore di bit per tenere traccia dei blocchi di dati liberi. Ogni bit del vettore rappresenta un blocco di dati, se il bit è 0 il blocco è libero, se il bit è 1 il blocco è occupato. Questo metodo è semplice da implementare ed è efficiente se riesce ad essere mantenuto in memoria principale, inoltre è semplice capire dove si trovano dei blocchi contigui. 
    \paragraph{Lista concatenata} In questo metodo, si usa una lista concatenata per tenere traccia dei blocchi di dati liberi. Ogni blocco di dati libero contiene un puntatore al blocco di dati libero successivo. Questo metodo è più complesso da implementare rispetto al metodo precedente, ma permette di ridurre al minimo lo spazio occupato per tenere traccia dello spazio libero, è però impossibile sapere se ci sono blocchi contigui liberi.
    \paragraph{Raggruppamento} In questo metodo, si usano delle liste concatenate per tenere traccia dei blocchi di dati liberi, ma si raggruppano al momento della rimozione di un file. In questo metodo si memorizza la dimensione della serie di blocchi liberi nel primo blocco libero e il puntatore al blocco libero successivo nell'ultimo blocco libero. In questo modo si riesce a tenere traccia dello spazio libero in modo più efficiente rispetto al metodo precedente, ed si riesce a sapere se ci sono blocchi contigui liberi.
\section{Efficienza e Prestazioni}
    Abbiamo appurato che il disco è il collo di bottiglia del sistema, dunque è necessario ottimizzare le prestazioni del \textit{file system} per migliorare le prestazioni del sistema. L'efficienza di un \textit{file system} dipende dall'algoritmo di allocazione dello spazio sul disco e dal tipo di dati contenuto nelle \textit{directory}. Le prestazioni del disco dipendono dal \textit{controller} fisico del disco, questo ha a disposizione una \textit{cache} per memorizzare i dati letti e scritti, ma ciò non è sufficiente per migliorare le prestazioni, vengono quindi usati dei meccanismi di dischi virtuali e cache del disco per migliorare le prestazioni.
    \paragraph{Dischi virtuali} I dischi virtuali sono dei dischi che vengono emulati tramite software e vengono memorizzati in memoria principale. Questi dischi sono gestiti interamente dall'utente e possono essere usati per memorizzare i dati in modo più efficiente rispetto ai dischi fisici, ma quando si spegne il computer i dati memorizzati nei dischi virtuali vengono persi. 
    \paragraph{Cache del disco} In questa tecnica viene memorizzata una copia dei blocchi di dati più usati in memoria principale, in modo da ridurre il numero di accessi al disco fisico. La cache del disco è gestita dal \texttt{SO} e sfrutta i principi di località spaziale e temporale per memorizzare i blocchi di dati più usati, i dati una volta modificati nella cache vengono scritti in \textit{background} sul disco fisico. sussistono problematiche di dimensione della cache, della politica di sostituzione e della scrittura dei dati. 
    \paragraph{Recupero dei dati} Inoltre ci sono dei problemi di consistenza dei dati e di controllo di questa consistenza.
    \paragraph{File system journaling} Il \textit{file system journaling} è una tecnica usata per garantire la consistenza dei dati in caso di crash del sistema. In questa tecnica, ogni operazione eseguita sul \textit{file system} viene registrata in un \textit{journal}, che è un file speciale memorizzato su disco. In caso di crash del sistema, il \text{file system} può ripristinare lo stato precedente usando il \textit{journal}.